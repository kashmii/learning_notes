#10
「useEffectとライフサイクルを理解して、ページが読み込まれたときにイベントを設定してみよう」

JSにおけるイベントというのは大きく分けて2種類
  1, ユーザーが何かしらの操作をしたときに発火するイベント
  2, ユーザーとは無関係に何かしらのタイミングで自動的に発火させるイベント

コンポーネントのライフサイクル
  1, マウント
    ... 一番最初にコンポーネントが表示されるとき
  2, アップデート
  3, アンマウント
    ... コンポーネントが画面から消えるとき

<注意点>
next.jsが管轄している範囲で、useEffectなどを使ってDOMを直接操作してはいけない

【useEffectについて】
useEffectフックは、Reactコンポーネントがマウントされたときやアップデートされたときに
副作用（side effect）を実行するために使用されます。

```
useEffect(() => {
  // 副作用のコード
}, [dependency1, dependency2, ...]);
```

useEffectの第二引数は、依存性配列と呼ばれ、この副作用が依存している変数やプロパティのリストを指定します。

依存性配列に指定された変数やプロパティが変更された場合、useEffectのコールバックが再実行されます。
依存性配列が空の場合、useEffectのコールバックはマウント時に一度だけ実行され、
アンマウント時にクリーンアップが行われます。

===

#11
「useStateの状態管理について解説！君はsetStateに関数を使っているか？」

コンポーネントとレンダリング時の描画について
  コンポーネント内の変数に変更を加えたとしても、そのコンポーネントが再レンダリングされない限りそれは反映されない

***
プチ情報
  useStateの返り値は配列であり、分割代入で取り出されることが通例
  オブジェクトにも分割代入は使える
  ex. import { useCallback, useEffect, useState } from 'react'
***

chatGPTの回答
<button onClick={() => setCount(count + 1)}>

しまぶーの推奨
<button onClick={() => setCount(count => count + 1)}>

「前の状態を用いて、それに対してなにか処理をしたい場合には、setXxxxに関数を渡したほうがよい」
  ※必ず関数を渡す必要があるわけではない、らしい

chatGPTの補足
  setCount(count + 1)の形式(関数ではなく数値を渡している)は、単純な処理の場合こちらが適しているとも言える

===

#12
「useEffectやuseCallbackの第2引数の配列について理解を深めよう」
  しまぶー曰く、reactの中でもハイレベルなのですぐに完全理解する必要はない

**第二引数の配列内の変数が更新されたら、中の関数が実行される**

【useCallback】
コールバック関数をメモ化するために使用される。
関数が同じインスタンスを保持し、パフォーマンスの向上や余分な再レンダリングを防ぐことができます
（クリーンアップ関数はない、あれはuseEffectのみ）
  利点3つ
    パフォーマンスの向上：useCallbackは、関数をメモ化するため、同じ関数インスタンスを再利用します。
      これにより、関数が再作成されるたびに発生するオーバーヘッドを削減し、パフォーマンスを向上させることができます。

    余分な再レンダリングの防止：useCallbackは、関数が依存する値が変更された場合にのみ再作成されるため、
      余分な再レンダリングを防ぐことができます。これにより、コンポーネントの再レンダリングが不要になり、
      パフォーマンスが向上します。

    メモリの節約：useCallbackは、同じ関数インスタンスを再利用するため、メモリの使用量を削減することができます。
      特に、コンポーネント内で複数のコールバック関数を使用する場合に効果的です。

useEffectとuseCallbackの違い

  useEffect は副作用を実行し、レンダリングサイクルの外で発生する処理を扱います
  useCallback はコールバック関数をメモ化し、パフォーマンスの向上や不要な再生成を防ぐために使います

===
#13
「useStateで文字列（string）や真偽値（boolean）を扱ってみよう」

reactではリターン文の中でif文を使えない(jsxの記法によるもの)。そのためかわりに三項演算子を使う

===
#14
「イミュータブルや破壊的メソッドを理解しよう！スプレッド構文を使う理由とは！？」

スプレッド構文
  不変性（イミュータビリティ）を保ちながら新しい配列やオブジェクトを作成するのに役立ちます
  スプレッド構文を使わずにコピーに使うと、参照渡しになってしまい、元の配列やオブジェクトにも影響が出てしまう

  ex. const originalArray = [1, 2, 3];
      const copiedArray = [...originalArray];

      console.log(copiedArray); // [1, 2, 3]
      console.log(originalArray === copiedArray); // false (別のオブジェクト)

      // originalも変更されてしまう
      const try_test = originalArray;
      try_test.shift();
      console.log(originalArray); // [2, 3]

  * 最近のJavaScriptにおいて、push/popなどの破壊的メソッドを使うことは推奨されていない
    そのため、配列の操作はスプレッド構文を使うことが多い

ミュータブル ... 意味：変更可能な
  ex. 配列やオブジェクト
イミュータブル ... 意味：変更不可能な
  ex. 文字列や数値

  Reactのシステムとして、元のオブジェクトに変更を加えてそれを返すような処理だと
  useCallback などの第二引数の配列が更新されない