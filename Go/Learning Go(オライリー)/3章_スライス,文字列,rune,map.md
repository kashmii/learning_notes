### := は関数の外では使えない

ただ、「関数の外で変数の宣言をする必要は殆どない」

### Goの定数はリテラルに名前をつけるだけ

変数がイミュータブルであることを宣言する方法はない

===

3章
3.1 配列
  「配列が直接使われることは多くない」
  理由： 「配列にはかなりの制約があるから」
    「よく使われるスライスの後方支援のために、配列は存在している」

3.2 スライス

  宣言時にインデックスを指定して要素を指定することができる（配列と同じ）
    var x = []int{1, 5: 4, 6, 10: 100, 15}
		fmt.Println(x) // [1 0 0 0 0 4 6 0 0 0 0 0 0 0 100 15]

  スライスと配列の違い
    1. 宣言時に大きさを指定しない／する
      slice := []int{1, 2, 3}
      array := [3]int{1, 2, 3}

  スライスのゼロ値はnil
    var x []int
    fmt.Println(x) // []
    fmt.Println(x == nil) // true

      配列の場合
        var x [3]int
        fmt.Println(x) // [0 0 0]
        var y [...]int
        fmt.Println(y) // エラー: invalid use of [...] array (outside a composite literal)

  3.2.1 len
    len関数はスライスの要素数を返す
      var x = []int{1, 2, 3}
      fmt.Println(len(x)) // 3

  3.2.2 append
    append関数はスライスに要素を追加する
      // 第1引数: スライス, 第2引数: 追加する要素
      var x []int
  		x = append(x, 10)

    演算子'...'を使うと、スライスを展開して渡すことができる
      var x = []int{1, 2, 3}
      var y = []int{4, 5, 6}
      x = append(x, y...)
      fmt.Println(x) // [1 2 3 4 5 6]

    ＜ポイント＞
      x = append(x, 10) のように、= の両脇にxを書く必要がある
        Goは値呼び出しの言語で、関数に引数を渡す際には必ず値をコピーして渡されている
        appendにスライスを渡すと、実際に渡されているのは「スライスのコピー」である
        そのため、append関数の第1引数にスライスを渡しても、スライスの中身を変更することはできない

  3.2.3 キャパシティ
    スライスの各要素はメモリ内の連続した領域に格納される
      → 素早い読み書きが可能

    スライスはキャパシティ（容量）を持っていて、append時にキャパシティを超えると、Goのランタイムが新たな領域にメモリを確保して、そこに要素をコピーする

    「Goのランタイム」
      ... 言語が依存しているプログラム実行のための一群のライブラリ
          Go言語のランタイムは、すべてのGoのバイナリファイルにコンパイル時に組み込まれる
          （この点で、ランタイム環境が別に必要な仮想マシンを使う言語とは異なる）

    3.2.4 make
      キャパシティを指定してスライスを作成する
        用途： あらかじめメモリを確保しておきたい場合、最大のサイズがわかっている場合
          var x = make([]int, 0, 5)
          fmt.Println(len(x), cap(x)) // 0 5

    ＜無駄を作らないよう気をつけるべきケース＞
      “appendは常にスライスの長さを大きくします。makeでスライスの正の長さ（n）を指定してからappendすると、スライスの先頭から（無駄な）ゼロ値がn個並んでしまいますので、注意が必要です。”



