スタック

LIFO（Last-In-First-Out）の原則に従った線形データ構造

関数呼び出しの実装（コールスタック）が、スタックの一般的な用途の 1つ

===
rubyの学び

def pop
  return nil if head.nil?
  temp = head
  # 右辺で self.headと書かなくても、head.next_nodeはメソッドが属しているオブジェクト（self）のhead属性と解釈される
  self.head = head.next_node
  temp
end

Q. 右辺ではselfなしで該当オブジェクトのheadにたどり着くことができる理由は？

A. 右辺でhead.next_nodeを参照する際に、headがローカル変数として既に存在している場合、Rubyは暗黙的にselfを補完しているためです。Rubyでは、メソッド内での変数の代入や参照において、メソッドが属しているオブジェクト（self）が暗黙的に補完される仕組みがあります。この仕組みを「selfの暗黙的な受け渡し」と呼びます。

===

スタックの各要素を配列に入れて出力させる問題
  必要な理由
    スタックは最新のものを扱うことに長けたデータ構造であり
    それ自体で一連のデータを扱うことはできないため。
