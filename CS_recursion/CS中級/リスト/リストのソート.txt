選択ソート
... とてもシンプルなソートアルゴリズム
    配列の未ソートの部分から最小の要素を選んで、現在の位置の要素と交換することを繰り返す
    この方法は in-place ソートと呼ばれています

    デメリット： 最初からリストのほとんどがソートされている場合、余分な計算量がかかってしまう

    計算量： O(n^2) (n: リストの要素数)

    ※個人メモ： 最小値を探すときは配列の添字を扱うようにするらしい

挿入ソート
... 2つ目以降の要素を、それより前の適切な位置に挿入していくことを繰り返す
    配列が[5, 4, 3, 2, 1]の場合、昇順に並び替えるにはかなり手間がかかる

    計算量： O(n^2) (最悪の場合)
            O(n) (最良の場合)

復習要： https://recursionist.io/dashboard/course/2/lesson/261
  選択ソート：1回済  挿入ソート： 0回

マージソート
... リストを半分に分割して、それぞれを再帰的にソートしてから、それらをマージしていく
    このアルゴリズムは、分割統治法と呼ばれるアルゴリズムの一種

    計算量： O(n log n)

    分割: 問題全体を同じ構造の小さな問題に分割します。
    統治: 分割した問題を、それ以上分割できない規模になるまで解きます。
    合併: 解いた多数の部分問題の解を、分割と逆の順番に併合していき、全体を一つに統合します。

    分割統治法： 問題を部分問題に分割しますが、これらの部分問題は重複せず、それぞれ独立的に解く
    動的計画法： 問題を部分問題に分割しますが、これらの部分問題は重複し、再利用される

復習要：このページの問題(分割統治法)
https://recursionist.io/dashboard/course/2/lesson/262

    分割していった最後の部分で返すのは、要素数1の配列。整数を返してはいけない

